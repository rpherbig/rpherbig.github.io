---
title: "Vibe Coding Is the Purest Form of Agile (And That's the Problem)"
layout: post
---

<link rel="canonical" href="https://sep.com/blog/vibe-coding-is-the-purest-form-of-agile/" />

> Vibe coding absolutely nails the values of Agile, and quietly violates the mechanisms that make Agile work.

Vibe coding might be the purest form of Agile we've ever seen. No standups, no tickets, no backlog grooming, just chaos and bliss. It nails the Agile values: working software, responding to change, and individuals over process. The loop is immediate. The feedback is constant. The friction is near zero. It feels like Agile distilled: velocity, autonomy, and iteration, without the weight of process.

Admittedly, vibe coding is an informal, emergent practice, not a process like Agile. But by turning certain Agile values up to maximum and stripping away everything else, vibe coding stress-tests which parts of Agile actually matter.

And that's where things get interesting. Because while vibe coding looks like Agile - maybe even more Agile than Agile has ever dared to be - it quietly violates the deeper structures that make Agile work over time. Shared understanding fades. Feedback loops turn inward. Coherence breaks down. It's not just fast, it's fragile.

If you think vibe coding is the future, ask how many of your experiments survived a second week. If you think Agile already solved all this, ask why vibe coding feels so much faster. Neither view is wrong, they're both incomplete.

# Vibe Coding Appears Deeply Aligned with Agile

**Working software over comprehensive documentation.** Vibe coding delivers code that runs, immediately. There's no spec to write, no ticket to close - just a tight loop of writing, testing, and refining. You see the result as you build. It's software first, everything else second.

**Responding to change over following a plan.** Plans barely exist in vibe coding. Every output is provisional. You revise prompts, rework logic, pivot direction on the fly. Change isn't a reaction - it's the baseline. Nothing gets locked in, and that's the point.

**Individuals and interactions over processes and tools.** Vibe coding is centered on the developer's direct engagement with the AI model. There's no ceremony, no defined roles. The interaction is immediate, continuous, and entirely individual-driven.

**Customer collaboration over contract negotiation.** There's always some input guiding the work: a user's need, a stakeholder's goal, or the developer's evolving sense of what's useful. The collaboration isn't formalized, but it's embedded in the loop. Build, observe, adjust: it happens in real time.

Bonus content (because changing the pattern mid-stream feels on-brand): **simplicity is the art of maximizing the amount of work not done**. Okay, this one's from the Agile principles, not the Manifesto itself - but vibe coding nails it anyway. There's no overhead, no filler, no wasted motion. It's just raw intent turned into running code, as directly as possible.

# But Vibe Coding Quietly Violates Agile's Deeper Principles

The most efficient and effective method of conveying information is **face-to-face conversation**. Vibe coding narrows the loop to a single person and their machine. Context lives in prompts, short-term memory, and intuition, not shared conversation. There's no mechanism for building a shared understanding across a team, because there's no team in the loop.

**Business people and developers must work together daily** throughout the project. Collaboration in vibe coding is optional at best. The loop loses the richness of diverse perspectives. Designers, testers, domain experts - they're all out of the loop. Feedback tends to be internal, based on feel, not validation. The result isn't just fragile software, it's narrow software: software that reflects local judgments, not shared goals. Vibe coding works best when the person writing the prompts already knows where the bodies are buried. They understand the context, the constraints, and the trade-offs without needing to ask. But that kind of tacit knowledge doesn't scale and it doesn't transfer. The fewer people involved, the more brittle the outcome becomes.

Agile processes promote **sustainable development**. Vibe coding burns hot. Without intentional pacing, prioritization, or checkpoints, developers tend to sprint until the architecture collapses or they spot the next shiny thing. Refactoring is often reactive, if it happens at all. More often, entropy wins. It's fast but not steady.

**Continuous attention to technical excellence enhances agility.** That attention rarely happens in vibe coding. The focus is on "Does it work right now?" not "Will it still work next week?" Quality, consistency, and structure tend to degrade unless intentionally reintroduced, but by then entropy has already taken hold.

**Working software is the primary measure of progress.** In vibe coding, "working" can mean "generates output" rather than "solves the right problem." Without external validation or shared definitions of done, progress becomes subjective and fragile.

And maybe the resemblance was never real to begin with. The Agile Manifesto doesn't reject the values on the right, it just prioritizes the ones on the left. Vibe coding often ignores the right entirely. It doesn't de-emphasize documentation, planning, validation, or collaboration - it ignores them. That's not an extreme form of Agile. It's something else pretending to be Agile because it happens to move fast.

# Bridging the Gap Between Vibe and Viability

Vibe coding feels like the purest form of Agile, but that purity turns out to be brittle. It strips away ceremony, friction, and delay, delivering working software with minimal overhead. But in doing so, it also strips away the mechanisms that make software sustainable: shared understanding, external validation, and coherence over time. And when you look closely, it's not just Agile pushed to its limits, it's something else entirely. It mimics the values but discards the balance. What looks like Agility becomes erosion by another name: ***frAgile***.

The solution isn't to abandon vibe coding or to force traditional process back onto it. It's to recognize where it falters and build lightweight practices that provide missing structure without killing the flow. Practices that preserve context, capture intent, and invite meaningful feedback, without getting in the way.

Vibe coding isn't broken. It's unfinished. It gives us speed, iteration, and flow, but not longevity, clarity, or shared direction. Vibe coding thrives in zero-overhead environments. But Agile assumes motivated individuals aren't left alone - they're supported, aligned, and operating in a shared context. Vibe coding removes the need for that support until it has to scale, share, or hand off. Then the missing scaffolding shows. What works beautifully in a solo loop collapses when we need to scale beyond more than one person - not because the tools are wrong, but because the patterns are missing. The challenge now is to shape practices that keep the momentum without sacrificing meaning. If vibe coding feels like the purest form of Agile, the next step is to ask: what does it take to make that purity scale?
